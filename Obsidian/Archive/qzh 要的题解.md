$
\newcommand{\ord}{\mathop{\rm ord}}
\newcommand{\leaf}{\mathop{\rm leaf}}
\newcommand{\seq}{\mathop{\rm split}}
$对这颗树的 dfs 序建一个线段树，这样每个节点的子树都对应了线段树上的一个区间。令 $u$ 的子树对应的线段树上区间为 $[l_u,r_u]$，其中 $l_u$ 是 $u$ 的 dfs 序。我们令 $\ord(u)=l_u$，其代表 $u$ 的 dfs 序。

线段树可以将任何一个子树对应的区间 $[l_u,r_u]$ 划分为 $O(\log n)$ 个线段树上节点 $v_1,\dots,v_k$ 对应的区间之并，我们用 $\seq(u)$ 表示区间 $[l_u,r_u]$ 被划分为的线段树上节点集合，即 $\seq(u)=\{v_1,\dots,v_k\}$。另外，我们用 $\leaf(v)$ 代表线段树上 $[\ord(v),\ord(v)]$ 区间对应的叶结点。在线段树上，$u$ 是 $v$ 的父亲意味着 $\ord(v)\in [l_u,r_u]$，同时也就意味着，一定存在 $w\in\seq(u)$ 使得 $w$ 是 $\leaf(v)$ 的祖先。

因此，可以设计一个直接的算法。

我们在每一个线段树节点 $w$ 上，对于所有的 $w\in\seq(u)$，以颜色为键值用 `map` 维护对每一种颜色 $c$，有哪些颜色为 $c$ 的节点 $u$，其分割恰好包含 $w$ 节点。可以用 `set` 维护以对所有满足条件的节点按深度排序。

对于修改操作 $u, c$，我们只需要对所有的 $w\in\seq(u)$，将 $u$ 原本颜色的信息删去，再将更新的颜色信息加入。因为 $\seq(u)$ 的大小是 $O(\log n)$ 的，而每次增删需要对 `map` 和 `set` 进行一次查询和修改操作，因此修改操作 $u,c$ 的复杂度为 $O(\log^2 n)$。

对于查询操作 $u, c$，我们可以直接从 $\leaf(u)$ 暴力向线段树的根节点遍历，对路径上每一个点 $w$ 查询其颜色 $c$ 中深度最深的节点。当且仅当 $v$ 是 $u$ 的祖先，即 $[l_v,r_v]$ 包含 $\ord(u)$ 时 $\seq(v)$ 才会与 $\leaf(u)$ 到根的路径上有交集，因此正确性显然。线段树的深度为 $O(\log n)$，对每一个节点需要对 `map` 做一次查询并对 `set` 求一次 `rbegin()`，因此查询操作 $u,c$ 的复杂度也为 $O(\log^2 n)$。
