---
Link: "[23NC10I](https://ac.nowcoder.com/acm/contest/57364/I)"
done: true
tags:
  - geometry
  - tree
---

要解决这个问题，我们首先需要把给出路径的每个端点定位到树上并重构，再在新树上解决问题。

题目保证了每个端点都在树的边或结点上。因为所有点的坐标都是有理数，所以可以用分数类来避免精度损失。我们先用 `map` 找到和结点重合的端点。

我们可以使用扫描线定位在边上的结点。因为题目保证了边只会在结点处相交，所以在扫描线的过程中，已经加入的边上下关系不会变化。注意我们需要特殊处理和 $y$ 轴平行的边。

因此，我们使用 `set` 按照边关于当前扫描线 $x=x_0$ 的截距维护所有和扫描线相交的边。如果两条边有着相同的截距，则用其关于扫描线 $x=x_0+\Delta$ 的截距作为第二关键字，其中 $\Delta$ 是任意正有理数。当我们定位端点 $p=(x_0,y_0)$ 时，我们可以构造一条边 $(x_0,y_0)\to(x_0+1,y_0+\infty)$ 来通过 `lower_bound` 找到 $p$ 所在的边。

因为时间限制很紧，我们可能无法在每次算出一个分数后都约分。但我们可以发现，我们只会在比较两条边关于某条扫描线 $x=x_0$ 截距大小的时候进行分数的运算和比较。通过优化，我们可以保证即使不对结果进行约分，计算截距时得到的结果 $p/q$ 也满足 $|p|\le 10^{19}$ 且 $q\le 10^{13}$。这样，就可以用 128 位整数类对截距大小进行比较。

我们在下文中使用下列记号：
- 我们将 $u$ 到 $v$ 的路径表示为 $u\to v$。
- 我们将 $u$ 在树上的父亲表示为 $\text{fa}(u)$。
- 我们将 $u$ 和 $v$ 的最近公共祖先表示为 $\text{lca}(u,v)$。
- 我们将从根到 $w$ 的路径上 $\text{lca}(u_i,v_i)$ 的数量定义为 $\text{cnt}(w)$，其中 $u_i\to v_i$ 是一条给出的路径。
- 我们将经过 $u$ 的路径 $u_i\to v_i$ 数量定义为 $\text{pass}(u)$。

在将边上端点进行定位后，我们可以在 $O(n+m)$ 的时间里重构一棵新树，使得所有路径的端点都是树上的一个结点。这样，我们就把这个问题转化为了普通的树上问题，其给出一棵树和一系列路径 $u_i\to v_i$，对每一条路径求有多少其他路径与其相交。

转化后的树上问题比端点定位简单很多。如果两条路径 $u_1\to v_1$, $u_2\to v_2$ 相交，则要么 $\text{lca}(u_1,v_1)$ 在 $u_2\to v_2$ 上，要么 $\text{lca}(u_2,v_2)$ 在 $u_1\to v_1$ 上，且仅当 $\text{lca}(u_1,v_1)=\text{lca}(u_2,v_2)$ 时二者同时发生。因此，$u_i\to v_i$ 相交的路径数量为 $\text{pass}(\text{lca}(u_i,v_i))+\text{cnt}(u_i)+\text{cnt}(v_i)-2\text{cnt}(\text{lca}(u_i,v_i))-1$，其中：
- $\text{pass}(\text{lca}(u_i,v_i))$ 是 $\text{lca}(u_i,v_i)$ 在其他路径上的情况。
- $\text{cnt}(u_i)+\text{cnt}(v_i)-2\text{cnt}(\text{lca}(u_i,v_i))$ 是 $\text{lca}(u_j,v_j)$ 在 $u_i\to v_i$ 上，除去 $\text{lca}(u_i,v_i)$ 的情况。
- $-1$ 是 $u_i\to v_i$ 本身。

$\text{cnt}(u)$ 和 $\text{pass}(u)$ 都可以在 $O(n+m)$ 的时间里通过树上差分求出。因此，总时间复杂度为 $O(n\log n+m\log m)$。