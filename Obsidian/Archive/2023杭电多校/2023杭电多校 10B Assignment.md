---
link: "[23HDU10B](http://acm.hdu.edu.cn/showproblem.php?pid=7384)"
done: true
tags:
  - combinatorics
  - dynamic-programming
---

因为 $A_{i,j}\ge A_{i,j-1}$，所以两次操作的区间只可能包含或相离，否则如果操作的区间相交，那么前一次操作一定可以在不让答案增加的情况下删除被后一次操作覆盖的部分。

接下来，我们考虑如何枚举操作。先考虑修改为与 $b$ 完全相同的情况，令当前区间为 $[l,r]$，如果 $a_l\neq b_l$，则可以枚举修改区间首端点的操作 $[l,m]$。因为操作之间不能相交，所以问题可以被分成两部分，一部分是 $[l+1,m]$ 上将全为 $b_l$ 的序列修改为与 $b$ 相同的的操作，另一部分是 $[m+1,r]$ 上将原有的序列修改为和 $b$ 相同的操作。 

因此，我们用 $f(l,r,i)$ 表示将 $a_l,\dots,a_r$ 修改为 $b_l,\dots,b_r$ 的最小代价，用 $g(l,r,u,i)$ 表示将当前全为 $u$ 的区间 $[l,r]$ 修改至和 $b$ 有至多 $i$ 个位置不同的最小操作代价。考虑如何转移，我们有：
- $f(l,r,i)$：
	- 当 $a_l=b_l$ 时，$f(l,r,i)=f(l+1,r,i)$。
	- 否则，不将 $a_l$ 修改为 $b_l$ 的操作代价为 $f(l+1,r,i-1)$，修改则枚举容错次数和修改右端点，操作代价为 $\min\limits_{0\le j\le i}\min\limits_{l\le m\le r} A_{b_l,m-l+1}+g(l+1,m,b_l,j)+f(r'+1,r,i-j)$。
- $g(l,r,u,i)$：
	- 当 $u=b_l$ 时，$g(l,r,u,i)=g(l+1,r,u,i)$。
	- 否则，不将 $a_l$ 修改为 $b_l$ 的操作代价为 $g(l+1,r,u,i-1)$，修改则枚举容错次数和修改右端点，操作代价为 $\min\limits_{0\le j\le i}\min\limits_{l\le m\le r}A_{b_l,m-l+1}+ g(l+1,m,b_l,j)+g(m+1,r,u,i-j)$。

注意到对任何有意义的修改操作都有 $b_l=b_m$，代入后可得对于所有 $g(l,r,u,i)$ 都有 $u=b_r$。因此，可以将 $g(l,r,u,i)$ 的第三维省去，状态数为 $O(n^2k)$，复杂度为 $O(n^3k^2)$。